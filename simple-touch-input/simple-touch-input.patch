From ec17952284ad1bc6e328df16024f3d39ca63ebec Mon Sep 17 00:00:00 2001
From: A Frederick Christensen <dwl@ivories.org>
Date: Sun, 14 Jan 2024 08:30:31 -0600
Subject: [PATCH] Add SIMPLE touchscreen handling

This is based in part on original work by Bastien Brouant, "Unprex" at
https://github.com/Unprex/dwl

!!!!!!!!!!!!!!!
In maintaining this patch, be sure to watch for changes to the
`motionabsolute` function:

The `touchdown` function here incorporates the contents of the
`motionabsolute` function, adds in the `wlr_cursor_warp_closest` call
and then the button press.

If `motionabsolute` is modified, `touchdown` should (likely) mirror
any of its modifications.
!!!!!!!!!!!!!!!

KNOWN BUGS:

- Sometimes, the pointer moves to where the screen is pressed, but the
button press doesn't occur until the screen is touched AGAIN. This
means that if you touch to click button 'Q' on the screen (for
instance), nothing happens; then you touch elsewhere on the screen and
THEN button 'Q' registers a click. This is annoying, doesn't always
happen, and I don't yet know how to fix it.
---
 dwl.c | 83 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 83 insertions(+)

diff --git a/dwl.c b/dwl.c
index d508d79..0773473 100644
--- a/dwl.c
+++ b/dwl.c
@@ -47,6 +47,7 @@
 #include <wlr/types/wlr_session_lock_v1.h>
 #include <wlr/types/wlr_single_pixel_buffer_v1.h>
 #include <wlr/types/wlr_subcompositor.h>
+#include <wlr/types/wlr_touch.h>
 #include <wlr/types/wlr_viewporter.h>
 #include <wlr/types/wlr_virtual_keyboard_v1.h>
 #include <wlr/types/wlr_virtual_pointer_v1.h>
@@ -264,6 +265,7 @@ static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_pointer *pointer);
 static void createpointerconstraint(struct wl_listener *listener, void *data);
+static void createtouch(struct wlr_touch *touch);
 static void cursorconstrain(struct wlr_pointer_constraint_v1 *constraint);
 static void cursorframe(struct wl_listener *listener, void *data);
 static void cursorwarptohint(void);
@@ -334,6 +336,8 @@ static void togglefloating(const Arg *arg);
 static void togglefullscreen(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
+static void touchdown(struct wl_listener *listener, void *data);
+static void touchup(struct wl_listener *listener, void *data);
 static void unlocksession(struct wl_listener *listener, void *data);
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
 static void unmapnotify(struct wl_listener *listener, void *data);
@@ -1041,6 +1045,50 @@ createpointerconstraint(struct wl_listener *listener, void *data)
 			&pointer_constraint->destroy, destroypointerconstraint);
 }
 
+void
+createtouch(struct wlr_touch *touch)
+{
+       if (wlr_input_device_is_libinput(&touch->base)) {
+               struct libinput_device *libinput_device =  (struct libinput_device*)
+                       wlr_libinput_get_device_handle(&touch->base);
+
+               if (libinput_device_config_tap_get_finger_count(libinput_device)) {
+                       libinput_device_config_tap_set_enabled(libinput_device, tap_to_click);
+                       libinput_device_config_tap_set_drag_enabled(libinput_device, tap_and_drag);
+                       libinput_device_config_tap_set_drag_lock_enabled(libinput_device, drag_lock);
+                       libinput_device_config_tap_set_button_map(libinput_device, button_map);
+               }
+
+               if (libinput_device_config_scroll_has_natural_scroll(libinput_device))
+                       libinput_device_config_scroll_set_natural_scroll_enabled(libinput_device, natural_scrolling);
+
+               if (libinput_device_config_dwt_is_available(libinput_device))
+                       libinput_device_config_dwt_set_enabled(libinput_device, disable_while_typing);
+
+               if (libinput_device_config_left_handed_is_available(libinput_device))
+                       libinput_device_config_left_handed_set(libinput_device, left_handed);
+
+               if (libinput_device_config_middle_emulation_is_available(libinput_device))
+                       libinput_device_config_middle_emulation_set_enabled(libinput_device, middle_button_emulation);
+
+               if (libinput_device_config_scroll_get_methods(libinput_device) != LIBINPUT_CONFIG_SCROLL_NO_SCROLL)
+                       libinput_device_config_scroll_set_method (libinput_device, scroll_method);
+
+               if (libinput_device_config_click_get_methods(libinput_device) != LIBINPUT_CONFIG_CLICK_METHOD_NONE)
+                       libinput_device_config_click_set_method (libinput_device, click_method);
+
+               if (libinput_device_config_send_events_get_modes(libinput_device))
+                       libinput_device_config_send_events_set_mode(libinput_device, send_events_mode);
+
+               if (libinput_device_config_accel_is_available(libinput_device)) {
+                       libinput_device_config_accel_set_profile(libinput_device, accel_profile);
+                       libinput_device_config_accel_set_speed(libinput_device, accel_speed);
+               }
+       }
+
+       wlr_cursor_attach_input_device(cursor, &touch->base);
+}
+
 void
 cursorconstrain(struct wlr_pointer_constraint_v1 *constraint)
 {
@@ -1412,6 +1460,9 @@ inputdevice(struct wl_listener *listener, void *data)
 	case WLR_INPUT_DEVICE_POINTER:
 		createpointer(wlr_pointer_from_input_device(device));
 		break;
+       case WLR_INPUT_DEVICE_TOUCH:
+               createtouch(wlr_touch_from_input_device(device));
+               break;
 	default:
 		/* TODO handle other input device types */
 		break;
@@ -2427,6 +2478,10 @@ setup(void)
 	LISTEN_STATIC(&cursor->events.button, buttonpress);
 	LISTEN_STATIC(&cursor->events.axis, axisnotify);
 	LISTEN_STATIC(&cursor->events.frame, cursorframe);
+	LISTEN_STATIC(&cursor->events.touch_down, touchdown);
+	LISTEN_STATIC(&cursor->events.touch_frame, cursorframe);
+	LISTEN_STATIC(&cursor->events.touch_motion, motionabsolute);
+	LISTEN_STATIC(&cursor->events.touch_up, touchup);
 
 	cursor_shape_mgr = wlr_cursor_shape_manager_v1_create(dpy, 1);
 	LISTEN_STATIC(&cursor_shape_mgr->events.request_set_shape, setcursorshape);
@@ -2644,6 +2699,34 @@ toggleview(const Arg *arg)
 	printstatus();
 }
 
+void
+touchdown(struct wl_listener *listener, void *data)
+{
+       struct wlr_pointer_button_event *button_event = data;
+
+       struct wlr_pointer_motion_absolute_event *event = data;
+       double lx, ly, dx, dy;
+
+       wlr_cursor_absolute_to_layout_coords(cursor, &event->pointer->base, event->x, event->y, &lx, &ly);
+       wlr_cursor_warp_closest(cursor, &event->pointer->base, lx, ly);
+       dx = lx - cursor->x;
+       dy = ly - cursor->y;
+       motionnotify(event->time_msec, &event->pointer->base, dx, dy, dx, dy);
+
+       button_event->button=BTN_LEFT;
+       button_event->state=WLR_BUTTON_PRESSED;
+       buttonpress(listener, button_event);
+}
+
+void
+touchup(struct wl_listener *listener, void *data)
+{
+       struct wlr_pointer_button_event *button_event = data;
+       button_event->button=BTN_LEFT;
+       button_event->state=WLR_BUTTON_RELEASED;
+       buttonpress(listener, button_event);
+}
+
 void
 unlocksession(struct wl_listener *listener, void *data)
 {
-- 
2.43.2

